#!/usr/bin/env python

# Copyright 2013 Mike Burns
# License under BSD. See LICENSE for details.

import sys
import os
import tempfile
import readline
import re
import subprocess
import cmd


class Gitsh(cmd.Cmd):
    def preloop(self):
        self._set_prompt()

    def precmd(self, line):
        if line == 'EOF' or line == '':
            return line
        elif line.startswith("\\"):
            name = self._backslash_command_line(line[1])
            return "backslash_%s %s" % (name, line[2:])
        else:
            return "git_command %s" % line

    def postcmd(self, stop, line):
        if not stop:
            self._set_prompt()
        return stop

    def do_EOF(self, _line):
        print
        return True

    def do_backslash_editor(self, _line):
        (fd, pathname) = tempfile.mkstemp(suffix='sh')
        fh = os.fdopen(fd)
        prior_stdin = self.stdin
        try:
            subprocess.call("%s %s" % (self._get_editor(), pathname), shell=True)
            self.stdin = fh
            self.cmdloop()
        except OSError as e:
            print >>sys.stderr, e
        finally:
            self.stdin = prior_stdin
            fh.close()
            os.unlink(pathname)

    def do_shell(self, line):
        try:
            if line == "":
                subprocess.call("%s -i" % self._get_shell(), shell=True)
            else:
                subprocess.call("%s -c '%s'" % (self._get_shell(), line), shell=True)
        except OSError as e:
            print >>sys.stderr, e

    def do_backslash_shell(self, line):
        return self.do_shell(line)

    def do_help(self, _line):
        print "\\!\trun shell"
        print "\\?\tshow this help"
        print "\\\"\twrite a string"
        print "\\c\tchange directory"
        print "\\e\topen editor"
        print "\\h\tshow help for a give topic"
        print "\\q\tquit"

    def do_backslash_help(self, line):
        return self.do_help(line)

    def do_backslash_git_help(self, topic):
        try:
            subprocess.call("git --help %s" % topic, shell=True)
        except OSError as e:
            print >>sys.stderr, e

    def do_backslash_quit(self, _line):
        return True

    def do_backslash_change_directory(self, directory):
        if directory == "":
            print os.getcwd()
        else:
            os.chdir(os.path.expanduser(directory.strip()))

    def do_backslash_string(self, string):
        print string.rstrip('"')

    def do_git_command(self, line):
        try:
            subprocess.call("git %s" % line, shell=True)
        except OSError as e:
            print >>sys.stderr, e

    def default(self, line):
        return self.do_git_command(line)

    def emptyline(self):
        return self.do_git_command("status")

    def _get_editor(self):
        return os.environ['VISUAL'] or os.environ['EDITOR'] or 'vi'

    def _get_shell(self):
        return os.environ['SHELL'] or 'sh'

    def _backslash_command_line(self, flag):
        return {'e': 'editor',
                '!': 'shell',
                '?': 'help',
                'h': 'git_help',
                'q': 'quit',
                'c': 'change_dir',
                '"': 'string'}[flag]

    def _set_prompt(self):
        prompter = Prompter()
        self.prompt = prompter.make_prompt()


class Prompter(object):
    def make_prompt(self):
        (branch, clean) = self._git_status()
        prompt = self._prompt_format().replace('%c', self._prompt_color(clean)).replace('%w', self._prompt_reset_color()).replace('%b', branch).replace('%#', self._prompt_terminator(clean)).replace('%d', os.getcwd()).replace('%D', os.path.basename(os.getcwd()))
        return prompt


    def _prompt_format(self):
        """
        %c - start coloring based on status
        %w - stop coloring based on status
        %b - branch name
        %# - prompt terminator, changes based on status
        %d - current directory, absolute
        %D - current directory, just basename
        """
        return "%b%c%#%w "

    def _git_status(self):
        status = os.popen('git status 2>&1').read()
        if re.search("Not a git repository", status):
            return ('uninitialized', 'uninitialized')
        elif re.search("Not currently on any branch", status):
            return ('(no branch)', 'no-branch')

        branch = re.search("On branch (.*)", status).group(1)

        if re.search("working directory clean", status):
            return (branch, 'clean')
        elif re.search("[uU]ntracked files", status):
            return (branch, 'untracked')
        elif re.search("Changes to be committed", status):
            return (branch, 'added')
        elif re.search("deleted:", status):
            return (branch, 'deleted')
        elif re.search("modified:", status):
            return (branch, 'modified')

    def _prompt_color(self, clean):
        return {'clean': "\033[00m",
                'untracked': "\033[00;31m",
                'added': "\033[00;33m",
                'deleted': "\033[00;33m",
                'modified': "\033[00;33m",
                'uninitialized': "\033[00;41m",
                'no-branch': "\033[00;34m",
                }[clean]

    def _prompt_reset_color(self):
        return "\033[00m"

    def _prompt_terminator(self, clean):
        return {'clean': '@',
                'untracked': '!',
                'added': '&',
                'deleted': '&',
                'modified': '&',
                'uninitialized': '!!',
                'no-branch': '*'}[clean]


class Completer(object):
    """
    Callable object that provides readline tab completion for git commands.
    """

    @classmethod
    def register(cls):
        """
        Registers an instance of Completer as the readline completer, and binds
        the tab key to complete in a way that is compatible with both
        GNU readline and libedit.
        """
        if 'libedit' in readline.__doc__:
            readline.parse_and_bind('bind ^I rl_complete')
        else:
            readline.parse_and_bind('tab: complete')
        readline.set_completer(cls())

    def __call__(self, text, n):
        """
        Behaves as a readline completion function (that is, given text and n,
        it returns the nth possible completion beginning with text)
        """
        competions = self._competions_for(text)
        if n < len(competions):
            return competions[n]
        else:
            return None

    def _competions_for(self, text):
        return filter(lambda s: s.startswith(text), self._git_commands())

    def _git_commands(self):
        """
        Returns all possible git commands, as listed by `git help -a`. This is
        based on the official git bash completion script.
        """
        if not hasattr(self, '_commands'):
            matcher = re.compile(r'^  [^ ]')
            splitter = re.compile(r'\s+')
            self._commands = set()
            output = subprocess.check_output(('/usr/bin/env', 'git', 'help', '-a'))
            for line in output.splitlines():
                if matcher.match(line):
                    map(self._commands.add, splitter.split(line.strip()))
        return self._commands


def interactive():
    return os.isatty(sys.stdin.fileno()) and len(sys.argv) == 1

if __name__ == '__main__':
    if 'libedit' in readline.__doc__:
        readline.parse_and_bind('bind ^I rl_complete')

    program = Gitsh()
    if interactive():
        program.complete = Completer()
        program.cmdloop()
    elif len(sys.argv) > 1:
        fh = open(sys.argv[1])
        program.stdin = fh
        program.use_rawinput = False
        program.cmdloop()
        fh.close()
    else:
        program.cmdloop()
